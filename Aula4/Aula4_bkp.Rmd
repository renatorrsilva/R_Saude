---
title: "Introdução ao software R: Aplicações na área da saúde - Módulo I"
subtitle: "Aula 4 - Estudo de Caso"
author: "Presented by Renato Rodrigues Silva"
institute: "Federal University of Goias."
date: "(updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false


---




class: middle
##Introdução


- O objetivo da aula é fazer a importação, limpeza e formatação dos dados, visualização e alguns testes de hipóteses a respeito dos dados de Covid-19 que estão armazenados no banco de dados SIVEP.

- Para fins didáticos, o objetivo do nosso estudo é verificar a mortalidade de pacientes diagnosticados com Covid 19 no Estado de Goiás. Adicionalmente, vamos estudar de forma simples uma associação entre o desfecho negativo e morbidades.



###Conjunto de dados - SIVEP

- O conjunto de dados analisado na aula de hoje é oriundo do Sistema de Informação da Vigilância Epidemiológica da Gripe (SIVEP-Gripe).

- Temos registros desde o dia 20 de março de 2020 até 19 de outubro de 2020.



---
class: middle
##Leitura dos dados

- Vamos começar carregando a biblioteca tidyverse, lendo os dados e dando uma visualizada rápida com o comando

```{r, eval = FALSE, message = FALSE, warning = FALSE}

library(tidyverse)

dat = read.csv("sivep_atualizado.csv", header= TRUE)

glimpse(dat)

```

```{r, echo = FALSE, message = FALSE, warning = FALSE}

library(tidyverse)

dat = read.csv("sivep_atualizado.csv", header= TRUE)

```


---
class: middle
##Alguns comentários 

- Como podemos perceber, o conjunto de dados é grande. Temos 8340 linhas e 165 colunas.

- Vale lembrar que no banco SIVEP não temos apenas dados de Covid-19, temos outras síndromes e doenças.

- Sendo assim, precisamos saber como filtrar esses dados.


---
class: middle
##Filtragem dos dados - Tabela de Frequencia Absoluta


- Inicialmente, vamos conferir a frequência absoluta dos pacientes de acordo com a classficação final

- O campo `CLASSI_FIN` tem as seguintes classificações: 1. 1-SRAG por influenza; 2. 2-SRAG por outro vírus respiratório; 3-SRAG por outro agente etiológico; 4-SRAG não especificado e 5-SRAG por COVID-19.

- O comando `table` calcula a frequencia absoluta.

```{r}

table( dat$CLASSI_FIN,exclude = NULL)
```


- Observe que temos 4988 registros de pacientes classficados como SRAG-Covid19.


---
class: middle
##Filtragem dos dados - Tabela de Frequencia Absoluta

- Podemos investigar um pouco mais sobre esses 4988 registros.

- Como exemplo, pode-se investigar qual foi o procedimento de diagnostico da doença

- No campo `CRITERIO` temos as seguintes opções: 1-Laboratorial; 2-Clinico-Epidemiológico; 3-Clínico e 4-Clínico-Imagem.

- Vamos contar a frequência deles

```{r}
table(dat$CRITERIO, exclude = NULL)
```


- O interessante é ter 1157 registros em que não se sabe como foi o critério de encerramento do caso.

---
class: middle
##Filtragem dos dados - Tabela de Contigência

- Agora vamos cruzar as informações entre os campos `CRITERIO` e `CLASSI_FIN` para verficar inconsistência.

- Fazendo a tabela de contigência entre os campos `CRITERIO` e `CLASSI_FIN`, temos:

```{r}
table(dat$CRITERIO, dat$CLASSI_FIN, exclude = NULL) %>% addmargins()
```

---
class: middle
##Filtragem dos dados - Tabela de Contigência

###Interpretações
 
- Dentre 4988  pacientes classificados como SRAG por Covid19, temos:

-  4579 por critério Laboratorial;
-  49 por critério Clinico-Epidemiológico; 
-  24 por critério Clínico;
- 184 por critério Clínico-Imagem;
- **152 não se sabe o critério**.



---
class: middle
##Filtragem dos dados - Tabela de Contigência

###Comando xtabs: Sintaxe  (frequencia ~ linhas + colunas)

```{r}
xtabs(~CRITERIO + CLASSI_FIN, data=dat, addNA = TRUE) %>% addmargins() 
```



---
class: middle
##Minerando os dados

####Selecionar os pacientes que testaram positivo para presença do vírus SARS-Cov2 via teste RT-PCR e classificados como SRAG-Covid19.

- O campo `PCR_SARS2` (nome do campo na base de dados) tem a seguinte descrição: Resultado diagnóstico do RT- PCR para (SARS-CoV- 2). Com a seguinte observação: Habilitado se campo 66- Agente etiológico – RT-PCR/outro método por Biologia Molecular:
Positivo para outros vírus? = 1.

- O contexto aqui é que a inserção de dados de Covid19 começou a partir desse ano, mas o SIVEP já registrava outros agentes que causavam síndromes gripais e síndrome respiratórias agudas graves há algum tempo.

- O campo que a descrição anterior se refere é o `POS_PCROUT`, cuja a descrição é dada por: Resultado da RT- PCR foi positivo para outros vírus que atacam o sistema respiratório.




---
class: middle
###Contando registros de testes RT- PCR

```{r}

xtabs( ~POS_PCROUT + PCR_SARS2, data = dat, subset = CLASSI_FIN == 5 & CRITERIO == 1, addNA = TRUE) %>% addmargins() 


```


- Logo, temos 3591 registros de pacientes que testaram positivo para SARS-Cov2 e que foram classificados como SRAG por Covid19 com critério laboratorial. 







---
class: middle

###Contando registros de testes antigênicos


```{r}

xtabs( ~AN_OUTRO + AN_SARS2, data = dat, subset  = CLASSI_FIN == 5 & CRITERIO == 1,
                                    addNA = TRUE) %>% addmargins() 

```


- Dentre dos 4579 pacientes classificados como SRAG por Covid19 por critério laboratorial, temos:

- 8 testaram positivo para outro vírus que atacam o sistema respiratório e para SARS-Cov2 (o que pode ser interpretado ter testado positivo somente para SARS Cov2 )

- 119 testaram positivo para SARS Cov2 e provavelmente para outros vírus que atacam o sistema respiratório que já eram monitorados no SIVEP.

[Testes Antigênicos:](https://sicnoticias.pt/especiais/coronavirus/2020-11-06-Covid-19.-O-que-sao-os-testes-de-antigenio-)


---
class: middle

###Contando registros de testes sorológicos

```{r}

xtabs(~ TP_SOR, data = dat, subset =   CLASSI_FIN == 5 & CRITERIO == 1)


```

 - Dentre dos 4579 registros classificados como SRAG por Covid19 usando critérios laboratorial: 337 testaram positivos para Covid 19 com Teste rápido, 10 com teste Elisa,
24 com Quimiluminescência e 19 com outros testes.
 
 
---
class: middle

##Filtragem dos dados
 
####Obs: Baqui et. al. (2020) usaram apenas pacientes diagnosticados com Covid19 e confirmados por meio do teste RT-PCR. Vamos utilizar um critério igual para a primeira filtragem.


```{r}

datRT_PCR = filter(dat, CLASSI_FIN == 5 & POS_PCROUT == 1 &  PCR_SARS2 == 1)

dim(datRT_PCR)

```

- Temos 3706 registros de pacientes classificados como SRAG por Covid19 e confirmados por meio do teste RT-PCR, veja que não necessariamente o critério de encerramento foi laboratorial.
 

---
class: middle

##Filtragem dos dados

##Local de Notificação versus Internação versus Residência do Paciente

- Uma vez que desejamos fazer uma análise do surto de Covid19 no Estado de Goiás, temos um possível conflito entre  município da unidade de sentinela onde foi feita a notificação, município de residência do paciente e município da internação.

- Para fins didáticos, eu vou fazer a seguinte filtragem. Serão comsiderados apenas os registros dos municipios das unidades de sentinela onde foram feitas as notificações dentro do Estado de Goiás. 

- Ou seja, registros de cidadãos goianos que foram notificados em outros Estados e/ou no Distrito Federal serão desconsiderados.


---
class: middle

##Filtragem dos dados referentes a municípios

- Para fazer essa segunda filtragem, precisamos inicialmente descobrir quais são todos os municípios das unidades de sentinelas onde foram feitas as  notificações.

- Uma forma de fazer isso é determinar quais são os distintos elementos do campo `ID_MUNICIP` condicionado a Unidade de Federação ser o Estado de Goiás.

- Para saber a unidade de federação devemos consultar o campo `SG_UF_NOT`.



---
class: middle

##Filtragem dos dados referentes a municípios

- Para começar a fazer a nossa tarefa, podemos utilizar os seguintes comandos:

```{r}

mn = filter(datRT_PCR, SG_UF_NOT == "GO" ) %>% select(ID_MUNICIP) %>% distinct()

```

- Essa linha de comando cria um data.frame com todos os municípios de unidades de sentinela onde foram feitas as notificações.


---
class: middle

##Filtragem dos dados referentes a municípios

 - Agora podemos a fazer a filtragem dos registros que atendem as nossas necessidades.
 
 
```{r}

dat_mn = filter(datRT_PCR, ID_MUNICIP %in% mn$ID_MUNICIP)

```

 - Para verificar se está tudo ok, basta eu fazer uma tabela de frequencia do campo `SG_UF_NOT`. Todos os registros devem pertencer ao estado de Goiás.
 
 
```{r}
xtabs(~SG_UF_NOT, data = dat_mn, addNA = TRUE)

```


---
class: middle

##Filtragem dos dados - Evolução Caso

- O campo `EVOLUCAO` tem as seguintes opções: 1-Cura; 2-Óbito 3- Óbito por outras causas 9-Ignorado.

- Inicialmente, vamos calcular a frequencia absoluta


```{r}

xtabs(~EVOLUCAO, data = dat_mn, addNA = TRUE)

```


- Observa-se que 226 registros não tem qualquer classificação. 

- Uma possível interpretação: tanto o código 9 como não preenchimento (NA) seria que o paciente ainda está em tratamento ou foi transferido para outra unidade de saúde.


[Prevalência IPTSP](https://files.cercomp.ufg.br/weby/up/59/o/Modulo1-Estudosdeprevalencia.pdf)


---
class: middle

##Estudando Morbidades

- Agora vamos estudar as morbidades no conjunto de dados.

- Para isso, inicialmente vamos analisar o campo 'FATOR_RISC'

- Esse campo é descrito como sendo: "Paciente apresenta algum fator de risco", com as seguinte opções: 1-Sim; 2-Não e 9-Ignorado.

- Segundo o nosso entendimento, as morbidades são preenchidas da seguinte forma: 

- Caso houver um fator de risco o campo 'FATOR_RISC' assume 1 e os campos referentes as morbidades são preenchidos.

- Caso o paciente não tiver qualquer fator de risco, o campo 'FATOR_RISC' assume 2 e os campos referentes as morbidades não são preenchidas.

- Vamos verificar essas suposições: Os nomes dos campos referentes as morbidades são:
`CARDIOPATI`, `HEMATOLOGI`, `HEPATICA`, `ASMA`, `DIABETES`, `NEUROLOGIC`, `PNEUMOPATI`, `IMUNODEPRE`, `RENAL` e `OBESIDADE`.

- Para verificar essa hipótese vamos inicialmente fazer uma tabela de contigência entre os campos `FATOR_RISC` e `CARDIOPATI`.

---
class: middle

##Estudando Morbidades




```{r}

xtabs(~  CARDIOPATI, addNA = TRUE, data = dat_mn)

xtabs(~ FATOR_RISC + CARDIOPATI, addNA = TRUE, data = dat_mn)

```

- Podemos interpretar que 1314 registros na verdade não tem qualquer fator de risco e portanto não sofrem de cardiopatia. Cabe ao analista corrigir essa inconsistência. 

- Por outro lado, para 365 registros (335 +30=365), não se sabe o diagnostico do paciente quanto à cardiopatias.


---
class: middle

##Estudando Morbidades - Corrigindo inconsistências

```{r}

morbs = c("CARDIOPATI", "HEMATOLOGI", "HEPATICA", "ASMA", "DIABETES", "NEUROLOGIC","PNEUMOPATI", "IMUNODEPRE", "RENAL", "OBESIDADE")

corr.morbs = function(x){  ifelse(dat_mn$FATOR_RISC ==2, 2, x)    }

dat_mnF = mutate_at(dat_mn, morbs, corr.morbs)

xtabs(~ FATOR_RISC + CARDIOPATI, addNA = TRUE, data = dat_mnF)


xtabs(~  CARDIOPATI, addNA = TRUE, data = dat_mnF)

```

---
class: middle

##Estudando Morbidades - Corrigindo inconsistências

 - Deste ponto em diante, não há mais distinção entre os códigos 9 e NA, portanto podemos subsitutir 9 por NA


```{r}


variaveis = c("EVOLUCAO","CARDIOPATI", "HEMATOLOGI", "HEPATICA", "ASMA", "DIABETES", "NEUROLOGIC","PNEUMOPATI", "IMUNODEPRE", "RENAL", "OBESIDADE")

corr.na = function(x){  ifelse(x ==9,NA, x)    }

dat_mnF = mutate_at(dat_mnF, variaveis, corr.na )

xtabs(~ FATOR_RISC + CARDIOPATI, addNA = TRUE, data = dat_mnF)


xtabs(~  CARDIOPATI, addNA = TRUE, data = dat_mnF)

```


[Faixa Etária:](https://www.rdocumentation.org/packages/SciencesPo/versions/1.02.12/topics/ageGroups).


---
class: middle

##Tabelas de Distribuição de Frequencias


- Para fazer calculo de frequencia relativa, podemos usar a função `CrossTable()` do pacote `gmodels`.

- Essa função não é eficiente para fazer tabelas de contigência com dados perdidos, mas por outro lado tem inúmeras vantagens

- Vamos fazer aqui a tabela de frequencia da evolução dos casos


---
class: middle


.pull-left[

####Tabelas de Frequencia Unidimensional

```{r,eval = FALSE}

#install.packages("gmodels")

library(gmodels)

CrossTable(dat_mnF$EVOLUCAO,    digits=3,,format = "SPSS")

```


####Tabelas Bidimensionais com Linhas Fixadas


```{r, eval = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           expected = FALSE, prop.chisq = FALSE,
           digits=3,
           prop.r=TRUE,prop.c=FALSE, prop.t = FALSE,
           format = "SPSS")

```



]


.pull-right[




####Tabelas Bidimensionais com Colunas Fixadas


```{r, eval = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           digits=3,
           expected = FALSE, prop.chisq = FALSE,
           prop.r=FALSE,prop.c=TRUE, prop.t = FALSE,
           format = "SPSS")

```


##Teste de Indepemdencia


```{r, eval  = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           expected = TRUE, prop.chisq = FALSE,
           chisq = TRUE,digits=3,
           prop.r=FALSE,prop.c=FALSE, prop.t = FALSE,
           format = "SPSS")

```




]


---
class: middle

####Tabelas de Distribuição de Frequencias

```{r,echo = FALSE}

library(gmodels)

CrossTable(dat_mnF$EVOLUCAO,   max.width = 3, format = "SPSS")

```



---
class: middle

###Tabelas de Distribuição de Frequencias Bidimensionais - Linhas Fixadas


```{r, echo  = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           expected = FALSE, prop.chisq = FALSE,
             max.width = 3,
           prop.r=FALSE,prop.c=FALSE, prop.t = FALSE,
           format = "SPSS")

```




---
class: middle

###Tabelas de Distribuição de Frequencias Bidimensionais - Colunas Fixadas


```{r, echo  = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           expected = FALSE, prop.chisq = FALSE,
             max.width = 3,
           prop.r=FALSE,prop.c=TRUE, prop.t = FALSE,
           format = "SPSS")

```

---
class: middle


```{r, echo  = FALSE}

CrossTable(dat_mnF$EVOLUCAO, dat_mnF$CARDIOPATI, 
           expected = FALSE, prop.chisq = FALSE,
           chisq = TRUE,digits=3,
           prop.r=FALSE,prop.c=FALSE, prop.t = FALSE,
           format = "SPSS")
```


---
class: middle
##Estudos de Taxas de Mortalidade 


- Apenas por questões didáticas a respeito do uso do software R, vamos estimar taxa de mortalidade devido a SRAG por Covid 19 por 10000 habitantes em cada  regional de saúde.


- Os dados da população de cada regional de saúde foram obtidos a partir desse [endereço:](https://www.saude.go.gov.br/unidades-de-saude/regioes-de-saude#:~:text=Os%207%20munic%C3%ADpios%20jurisdicionados%20%C3%A0,maior%20191.139%20habitantes%20em%20Luzi%C3%A2nia.). Esse [endereço"](http://repositorio.bc.ufg.br/tede/handle/tede/9226) tem uma dissertação relacionada ao tema.

- Para fazer o estudo de prevalência, o primeiro passo é calcular o número de casos de SRAG por Covid19 por regional de saúde.



```{r, eval = FALSE}

pp = c(1781530,  849421, 248821, 812707, 286433, 145865, 140321,116841, 112423, 488380,
        199333, 167159 , 167391, 125947, 420427 ,215282, 243991)

dat_tx = group_by(dat_mnF, ID_REGIONA, EVOLUCAO) %>% summarise(obitos = n())  %>% filter(EVOLUCAO==2) %>% select(obitos) %>%ungroup() %>% mutate(pop = pp) %>% mutate(taxa = (obitos/pop)*10000) %>% mutate(taxa = round(taxa, digits=3))

dat_tx


```


---
class: middle
####Estudos de Taxas de Mortalidade 

```{r, echo = FALSE, message=FALSE, warning=FALSE}

pp = c(1781530,  849421, 248821, 812707, 286433, 145865, 140321,116841, 112423, 488380,
        199333, 167159 , 167391, 125947, 420427 ,215282, 243991)

dat_tx = group_by(dat_mnF, ID_REGIONA, EVOLUCAO) %>% summarise(obitos = n())  %>% filter(EVOLUCAO==2) %>% select(obitos) %>%ungroup() %>% mutate(pop = pp) %>% mutate(taxa = (obitos/pop)*10000) %>% mutate(taxa = round(taxa, digits=3))

dat_tx


```


---
class: middle
##Mapas coropléticos - Estudos de taxa de mortalidade de Covid 19

- Agora vamos tentar fazer um mapa coroplético que represente a taxa de mortalidade devido a Covid 19 por municípios do estado de Goiás.

- Os dados foram obtidos no seguinte [endereço:](ftp://ftp.ibge.gov.br/Estimativas_de_Populacao/Estimativas_2018/)



---
class: middle
##Mapas coropléticos - Estudos de taxa de mortalidade de Covid 19

 - Primeiro passo ler os dados referentes a população de Goiás e filtrar apenas os nomes referentes ao estado de Goiás.
 
- Para facilitar a união dos dois conjuntos de dados vamos instalar a biblioteca `textclean`. Essa biblioteca tem uma função que se chama `replace_non_ascii` que vai nos ajudar a remover todos os caracteres especiais dos nomes. A função `toupper` converte letras maiusculas em minusculas.
 
 
```{r, eval = FALSE, message=FALSE, warning=FALSE}

##install.packages("textclean")

library(textclean)

dat_IBGE = read.csv("Municipios.csv",header=TRUE,skip=1) %>% filter(COD..UF == 52) %>% mutate(POPULACAO = sub(",",".", POPULAÇÃO.ESTIMADA)) %>% mutate(NOME_MUNICIPIOS =replace_non_ascii(dat_IBGE$NOME.DO.MUNICÍPIO) %>% toupper()) %>% select(one_of(c("NOME_MUNICIPIOS", "POPULACAO")))



``` 
 

---
class: middle
##Mapas coropléticos - Estudos de taxa de mortalidade de Covid 19
 
```{r, echo= FALSE, message=FALSE, warning=FALSE}

##install.packages("textclean")

library(textclean)

dat_IBGE = read.csv("Municipios.csv",header=TRUE,skip=1) %>% filter(COD..UF == 52) %>% mutate(POPULACAO = sub(",",".", POPULAÇÃO.ESTIMADA)) %>% mutate(NOME_MUNICIPIOS =replace_non_ascii(NOME.DO.MUNICÍPIO) %>% toupper())  %>% select(one_of(c("NOME_MUNICIPIOS", "POPULACAO")))

head(dat_IBGE)

```

---
class: middle
##Mapas coropléticos - Estudos de taxa de mortalidade de Covid 19

- O próximo passo é calcular a o número de óbitos por municípios.


```{r, eval=FALSE}




```


---
class: middle
##Referências

- Baqui P, Bica I, Marra V, Ercole A, van der Schaar M. Ethnic and regional variations in hospital mortality from COVID-19 in Brazil: a cross-sectional observational study. Lancet Glob Health 2020; 8:e1018-e1026.

- Faculdade de Medicina. Universidade do Porto. Primeira aula prática curso de Medicina, terceiro ano. Disponível em: http://cc04-10.med.up.pt/Epidemiologiapraticas/Aula1_Nova.pdf. Acesso em 9 de dezembro de 2020.

- Quijano. F. A. D. Medidas de Frequência em Epidemiologia. Disponível em: https://edisciplinas.usp.br/pluginfile.php/4660029/mod_resource/content/2/Slides-MedidasFrequencia2019.pdf. Acesso em 9 de dezembro de 2020.


- Mayer, F. Análise Exploratória de Dados. Disponível em: 
http://leg.ufpr.br/~fernandomayer/aulas/ce001e-2016-2/02_Analise_Exploratoria_de_Dados.html. Acesso em 9 de dezembro de 2020.